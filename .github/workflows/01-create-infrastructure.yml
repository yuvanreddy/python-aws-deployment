name: 01 - Create AWS Infrastructure

on:
  workflow_dispatch:
    inputs:
      instance_count:
        description: 'Number of EC2 instances to create'
        required: false
        default: '2'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'
      instance_type:
        description: 'EC2 instance type'
        required: false
        default: 't3.micro'
        type: choice
        options:
          - 't3.micro'
          - 't3.small'
          - 't3.medium'
          - 't3.large'
      os_type:
        description: 'Operating System'
        required: false
        default: 'ubuntu'
        type: choice
        options:
          - 'ubuntu'
          - 'amazon-linux-2'
          - 'rhel'

env:
  TF_VAR_instance_count: ${{ github.event.inputs.instance_count || '2' }}
  TF_VAR_instance_type: ${{ github.event.inputs.instance_type || 't3.micro' }}
  TF_VAR_os_type: ${{ github.event.inputs.os_type || 'ubuntu' }}

jobs:
  create_infrastructure:
    name: Create AWS Infrastructure
    runs-on: ubuntu-latest
    outputs:
      instance_ids: ${{ steps.outputs.outputs.instance_ids }}
      vpc_id: ${{ steps.outputs.outputs.vpc_id }}
      public_ips: ${{ steps.outputs.outputs.public_ips }}
      private_ips: ${{ steps.outputs.outputs.private_ips }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Create S3 backend bucket
        run: |
          BUCKET_NAME="terraform-state-${{ github.repository_owner }}-python-deployment"
          BUCKET_NAME=$(echo "$BUCKET_NAME" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "ğŸ“¦ Creating S3 bucket for Terraform state: $BUCKET_NAME"
            aws s3api create-bucket \
              --bucket "$BUCKET_NAME" \
              --region ${{ secrets.AWS_REGION }} \
              $(if [ "${{ secrets.AWS_REGION }}" != "us-east-1" ]; then echo "--create-bucket-configuration LocationConstraint=${{ secrets.AWS_REGION }}"; fi)
            
            aws s3api put-bucket-versioning \
              --bucket "$BUCKET_NAME" \
              --versioning-configuration Status=Enabled
            
            aws s3api put-bucket-encryption \
              --bucket "$BUCKET_NAME" \
              --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
            
            echo "âœ… S3 bucket created successfully"
          else
            echo "âœ… S3 bucket already exists: $BUCKET_NAME"
          fi
          
          echo "TERRAFORM_STATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV

      - name: Create DynamoDB table for state locking
        run: |
          TABLE_NAME="terraform-state-lock-python-deployment"
          REGION="${{ secrets.AWS_REGION }}"

          # If table exists, delete it to clear any stale Digest mismatches
          if aws dynamodb describe-table --table-name "$TABLE_NAME" --region "$REGION" >/dev/null 2>&1; then
            echo "ğŸ—‘ï¸ Deleting existing DynamoDB table: $TABLE_NAME"
            aws dynamodb delete-table --table-name "$TABLE_NAME" --region "$REGION"
            echo "â³ Waiting for table to be deleted..."
            aws dynamodb wait table-not-exists --table-name "$TABLE_NAME" --region "$REGION"
            echo "âœ… Deleted table: $TABLE_NAME"
          else
            echo "â„¹ï¸ Table not found, nothing to delete: $TABLE_NAME"
          fi

          echo "ğŸ”’ Creating DynamoDB table for state locking: $TABLE_NAME"
          aws dynamodb create-table \
            --table-name "$TABLE_NAME" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region "$REGION"

          echo "â³ Waiting for table to be active..."
          aws dynamodb wait table-exists --table-name "$TABLE_NAME" --region "$REGION"
          echo "âœ… DynamoDB table created successfully"

      - name: Initialize Terraform
        working-directory: terraform
        run: |
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket         = "${{ env.TERRAFORM_STATE_BUCKET }}"
              key            = "python-deployment/terraform.tfstate"
              region         = "${{ secrets.AWS_REGION }}"
              encrypt        = true
              dynamodb_table = "terraform-state-lock-python-deployment"
            }
          }
          EOF
          
          # Retry terraform init to handle transient S3/DynamoDB eventual consistency
          ATTEMPTS=0
          until terraform init -reconfigure; do
            ATTEMPTS=$((ATTEMPTS+1))
            if [ "$ATTEMPTS" -ge 3 ]; then
              echo "âŒ Terraform init failed after $ATTEMPTS attempts"
              exit 1
            fi
            echo "âš ï¸ terraform init failed (attempt $ATTEMPTS). Retrying in 20s..."
            sleep 20
          done
          echo "âœ… Terraform initialized"

      - name: Validate Terraform configuration
        working-directory: terraform
        run: |
          terraform validate
          echo "âœ… Terraform configuration is valid"

      - name: Plan Terraform changes
        working-directory: terraform
        run: |
          echo "ğŸ“‹ Planning infrastructure changes..."
          terraform plan \
            -var="aws_region=${{ secrets.AWS_REGION }}" \
            -var="key_pair_name=${{ secrets.KEY_PAIR_NAME }}" \
            -var="instance_count=${{ env.TF_VAR_instance_count }}" \
            -var="instance_type=${{ env.TF_VAR_instance_type }}" \
            -var="os_type=${{ env.TF_VAR_os_type }}" \
            -out=tfplan

      - name: Apply Terraform changes
        working-directory: terraform
        run: |
          echo "ğŸš€ Creating infrastructure..."
          terraform apply -auto-approve tfplan
          echo "âœ… Infrastructure created successfully"

      - name: Save Terraform outputs
        id: outputs
        working-directory: terraform
        run: |
          # Get outputs
          INSTANCE_IDS=$(terraform output -json instance_ids 2>/dev/null || echo "[]")
          VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "")
          PUBLIC_IPS=$(terraform output -json public_ips 2>/dev/null || echo "[]")
          PRIVATE_IPS=$(terraform output -json private_ips 2>/dev/null || echo "[]")
          
          # Save to GitHub outputs
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "public_ips=$PUBLIC_IPS" >> $GITHUB_OUTPUT
          echo "private_ips=$PRIVATE_IPS" >> $GITHUB_OUTPUT
          
          # Save to file for artifact
          cat > outputs.json << EOF
          {
            "instance_ids": $INSTANCE_IDS,
            "vpc_id": "$VPC_ID",
            "public_ips": $PUBLIC_IPS,
            "private_ips": $PRIVATE_IPS
          }
          EOF
          
          # Display summary
          echo "========================================="
          echo "ğŸ“Š INFRASTRUCTURE CREATED"
          echo "========================================="
          echo "VPC ID: $VPC_ID"
          echo "Instance IDs: $INSTANCE_IDS"
          echo "Public IPs: $PUBLIC_IPS"
          echo "Private IPs: $PRIVATE_IPS"
          echo "========================================="

      - name: Wait for instances to be ready
        run: |
          INSTANCE_IDS='${{ steps.outputs.outputs.instance_ids }}'
          echo "â³ Waiting for instances to be fully ready..."
          
          echo "$INSTANCE_IDS" | jq -r '.[]' | while read -r instance_id; do
            echo "Waiting for instance $instance_id..."
            aws ec2 wait instance-status-ok --instance-ids "$instance_id" --region ${{ secrets.AWS_REGION }}
            echo "âœ… Instance $instance_id is ready"
          done
          
          echo "âœ… All instances are ready for configuration"

      - name: Upload outputs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: terraform/outputs.json
          retention-days: 7

      - name: Display next steps
        run: |
          echo "========================================="
          echo "âœ… INFRASTRUCTURE READY"
          echo "========================================="
          echo "Next step: Run '02 - Install Python' workflow"
          echo "to install and configure Python on the instances"
          echo "=========================================="
